# 3. Алгоритмы и системы ⭐

[◀ Назад к оглавлению](README.md) | [▶ Следующий раздел: Техническая специфика](04_Техническая_специфика.md)

**Критически важно для разработчика механик**

---
### 2.5. Алгоритмы и системы ⭐ НОВЫЙ РАЗДЕЛ

#### 2.5.1. Grid System (Система сетки)

**Размер поля:**
- **Переменный размер:** настраивается для каждого уровня
- **Типовые размеры:** 6×6, 7×7, 8×8, 9×9, нестандартные формы
- **Конфигурация:**
  - Width: int (количество столбцов)
  - Height: int (количество строк)
  - Shape: enum {Rectangle, Custom}
  - CustomShape: bool[,] массив для нестандартных форм (true = доступная клетка)

**Пример конфигурации уровня:**
```csharp
[Serializable]
public class LevelGridConfig
{
    public int width = 8;
    public int height = 8;
    public GridShape shape = GridShape.Rectangle;
    public bool[,] customCells; // Для нестандартных форм (L-образная, круглая и т.д.)
}

public enum GridShape
{
    Rectangle,    // Прямоугольник
    Custom        // Нестандартная форма (использовать customCells)
}
```

**Система координат:**
- Origin (0,0): левый нижний угол
- X: увеличивается вправо (0 → width-1)
- Y: увеличивается вверх (0 → height-1)
- Альтернатива (при необходимости): Origin в левом верхнем углу (как у массивов)

**Структура данных:**
- **Выбор разработчика:** тип структуры данных определяется разработчиком исходя из требований производительности и удобства
- **Варианты для рассмотрения:**
  - Двумерный массив: `Cell[,] grid` - простой доступ, фиксированный размер
  - Dictionary: `Dictionary<Vector2Int, Cell>` - гибкость для нестандартных форм
  - Пользовательский Grid<T> класс с индексатором
  - Одномерный массив с расчётом индекса: `Cell[] grid` + index = y * width + x

**Класс Cell (базовая структура клетки):**
```csharp
public class Cell
{
    public Vector2Int position;      // Координаты
    public GameElement element;      // Игровой элемент (может быть null)
    public Obstacle obstacle;        // Препятствие (может быть null)
    public bool isAvailable;         // Доступна ли клетка для игры
    public CellType cellType;        // Тип клетки (обычная, выход для ингредиентов, спавнер)
}
```

#### 2.5.2. Match Detection (Обнаружение совпадений)

**Алгоритм: Breadth-First Search (BFS)**

**Причины выбора BFS:**
- Эффективный поиск связных групп элементов
- Гарантирует нахождение всех элементов в группе
- Хорошая производительность для сеток малого/среднего размера

**Псевдокод алгоритма:**
```
function FindMatches(grid):
    matched_groups = []
    visited = Set()
    
    for each cell in grid:
        if cell not in visited and cell.element exists:
            group = BFS_Search(cell, visited)
            if group.size >= 3:
                matched_groups.add(group)
    
    return matched_groups

function BFS_Search(start_cell, visited):
    queue = Queue()
    queue.enqueue(start_cell)
    group = []
    target_type = start_cell.element.type
    
    while queue is not empty:
        current = queue.dequeue()
        if current in visited:
            continue
            
        visited.add(current)
        group.add(current)
        
        for neighbor in GetNeighbors(current):
            if neighbor.element.type == target_type and neighbor not in visited:
                queue.enqueue(neighbor)
    
    return group
```

**Направления поиска:**
- 4-направленное: вверх, вниз, влево, вправо
- Диагонали НЕ учитываются

**Оптимизация:**
- **Dirty Regions:** проверка только областей, затронутых последним ходом
- **Кэширование:** сохранение позиций элементов одного типа для быстрого доступа
- **Early Exit:** прекращение поиска, если найдены все возможные матчи в измененной области

**Определение формы комбинации:**
После нахождения группы определить:
1. Горизонтальные и вертикальные последовательности
2. Если есть пересечение → L, T, или крестообразная форма
3. Присвоить соответствующий бустер

#### 2.5.3. Shuffle System (Система перемешивания)

**Условия Deadlock (тупиковой ситуации):**
```
Deadlock = ∄ valid_move ∈ PossibleMoves(grid)
```

**Проверка наличия возможных ходов:**
1. Для каждой клетки с элементом
2. Проверить свап с соседними клетками (4 направления)
3. Симулировать обмен
4. Проверить наличие матча после обмена
5. Откатить симуляцию
6. Если найден хотя бы один валидный ход → Deadlock = false

**Алгоритм перемешивания (Fisher-Yates Shuffle):**
```
function ShuffleGrid(grid):
    elements = ExtractAllElements(grid)
    
    for i from elements.length - 1 down to 1:
        j = Random(0, i)
        Swap(elements[i], elements[j])
    
    PlaceElementsBack(grid, elements)
    
    // Проверка после перемешивания
    if DetectImmediateMatches():
        ShuffleGrid(grid)  // Рекурсивно, пока не будет стартовых матчей
    
    if not HasPossibleMoves():
        ShuffleGrid(grid)  // Рекурсивно, пока не появятся ходы
```

**Гарантия решаемости:**
- Максимальное количество попыток перемешивания: 100
- Если после 100 попыток не найдена валидная конфигурация → регенерация уровня с новыми параметрами
- Опционально: предварительная генерация решаемых конфигураций

**Визуальные эффекты:**
- Анимация перемешивания (опционально)
- Предупреждение игроку "No more moves! Shuffling..."
- Не считается как ход игрока

#### 2.5.4. Random Generation (Случайная генерация)

**Weighted Randomness (Взвешенная случайность):**
```csharp
public class WeightedRandom
{
    Dictionary<ElementType, float> weights;
    
    public ElementType GetRandomElement()
    {
        float totalWeight = weights.Values.Sum();
        float randomValue = Random.Range(0, totalWeight);
        
        float cumulative = 0;
        foreach (var kvp in weights)
        {
            cumulative += kvp.Value;
            if (randomValue <= cumulative)
                return kvp.Key;
        }
        
        return ElementType.Default;
    }
}
```

**Динамическая корректировка весов:**
- Увеличение веса для целевых элементов уровня
- Уменьшение веса для уже собранных элементов
- Формула: `adjusted_weight = base_weight × objective_multiplier`

**Seed Management (Управление seed):**
- **Для воспроизводимости:** сохранение seed для каждого уровня
- **Для тестирования:** фиксированный seed
- **Для продакшена:** случайный seed на основе timestamp + user_id
```csharp
Random.InitState(seed);
```

**Предотвращение стартовых матчей:**
При генерации нового элемента:
1. Сгенерировать случайный тип
2. Проверить, не создаст ли он матч 3+
3. Если создаёт → регенерировать другой тип
4. Максимум 10 попыток, затем принудительный выбор валидного типа

---

[◀ Предыдущий раздел: Основной геймплей](02_Основной_геймплей.md) | [▶ Следующий раздел: Техническая специфика](04_Техническая_специфика.md)
